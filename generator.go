package scru64

import (
	"fmt"
	"sync"
	"time"
)

// The error value returned by [Generator.Generate] and
// [Generator.GenerateOrAbortCore] when the relevant timestamp is significantly
// smaller than the one embedded in the immediately preceding ID generated by
// the generator.
var ErrClockRollback = fmt.Errorf(
	"scru64.Generator: detected unbearable clock rollback")

// Represents a SCRU64 ID generator.
//
// This structure must be instantiated by one of the dedicated constructors:
// [NewGenerator], [NewGeneratorParsing], or [NewGeneratorWithCounterMode].
//
// The generator comes with several different methods that generate a SCRU64 ID:
//
//	| Flavor              | Timestamp | Thread- | On big clock rewind |
//	| ------------------- | --------- | ------- | ------------------- |
//	| Generate            | Now       | Safe    | Returns error       |
//	| GenerateOrReset     | Now       | Safe    | Resets generator    |
//	| GenerateOrSleep     | Now       | Safe    | Sleeps              |
//	| GenerateOrAbortCore | Argument  | Unsafe  | Returns error       |
//	| GenerateOrResetCore | Argument  | Unsafe  | Resets generator    |
//
// All of these methods return a monotonically increasing ID by reusing the
// previous `timestamp` even if the one provided is smaller than the immediately
// preceding ID's, unless such a clock rollback is considered significant (by
// default, approx. 10 seconds). A clock rollback may also be detected when a
// generator has generated too many IDs within a certain unit of time, because
// this implementation increments the previous `timestamp` when `counter`
// reaches the limit to continue instant monotonic generation. When a
// significant clock rollback is detected:
//
//  1. `Generate` (OrAbort) methods abort and return the [ErrClockRollback]
//     error value immediately.
//  2. `OrReset` variants reset the generator and return a new ID based on the
//     given `timestamp`, breaking the increasing order of IDs.
//  3. `OrSleep` method sleeps and waits for the next timestamp tick.
//
// The `Core` functions offer low-level thread-unsafe primitives to customize
// the behavior.
type Generator struct {
	prev        Id
	counterSize uint8
	counterMode CounterMode
	lock        sync.Mutex
}

// Heuristically ensures that the receiver is initialized by valid constructors,
// or panics if not.
func (g *Generator) verify() {
	if g == nil || g.counterMode == nil {
		panic("method call on invalid receiver")
	}
}

// Creates a new generator with the given node configuration.
func NewGenerator(nodeSpec NodeSpec) *Generator {
	if nodeSpec.NodeIdSize() < 20 {
		return NewGeneratorWithCounterMode(nodeSpec, NewDefaultCounterMode(0))
	} else {
		// reserve one overflow guard bit if `counterSize` is very small
		return NewGeneratorWithCounterMode(nodeSpec, NewDefaultCounterMode(1))
	}
}

// Creates a new generator by parsing the given node spec string.
//
// This is a shortcut constructor that chains [ParseNodeSpec] and [NewGenerator]
// for convenience, panicking if the argument is not a valid node spec string.
func NewGeneratorParsing(nodeSpec string) *Generator {
	n, err := ParseNodeSpec(nodeSpec)
	if err != nil {
		panic(err)
	}
	return NewGenerator(n)
}

// Creates a new generator with the given node configuration and counter
// initialization mode.
//
// This constructor panics if `counterMode` is nil.
func NewGeneratorWithCounterMode(
	nodeSpec NodeSpec, counterMode CounterMode) *Generator {
	if counterMode == nil {
		panic("constructor called with nil `counterMode`")
	}
	return &Generator{
		prev:        nodeSpec.nodePrev,
		counterSize: nodeCtrSize - nodeSpec.NodeIdSize(),
		counterMode: counterMode,
	}
}

// Returns the `nodeId` of the generator.
func (g *Generator) NodeId() uint32 {
	g.verify()
	return g.prev.NodeCtr() >> g.counterSize
}

// Returns the size in bits of the `nodeId` adopted by the generator.
func (g *Generator) NodeIdSize() uint8 {
	g.verify()
	return nodeCtrSize - g.counterSize
}

// Returns the node configuration specifier describing the generator state.
func (g *Generator) NodeSpec() NodeSpec {
	n, _ := NewNodeSpecWithNodePrev(g.prev, g.NodeIdSize())
	return n
}

// Calculates the combined `nodeCtr` field value for the next `timestamp` tick.
func (g *Generator) renewNodeCtr(timestamp uint64) uint32 {
	nodeId := g.NodeId()
	counter := g.counterMode.Renew(g.counterSize,
		CounterModeRenewContext{Timestamp: timestamp, NodeId: nodeId})
	if counter >= (1 << g.counterSize) {
		panic("illegal `CounterMode` implementation")
	}
	return nodeId<<g.counterSize | counter
}

// Generates a new SCRU64 ID object from the current `timestamp`, or returns an
// error upon significant timestamp rollback.
//
// See the [Generator] type documentation for the description.
//
// This method returns the [ErrClockRollback] error upon significant clock
// rollback.
func (g *Generator) Generate() (Id, error) {
	g.lock.Lock()
	defer g.lock.Unlock()
	return g.GenerateOrAbortCore(uint64(time.Now().UnixMilli()), 10_000)
}

// Generates a new SCRU64 ID object from the current `timestamp`, or resets the
// generator upon significant timestamp rollback.
//
// See the [Generator] type documentation for the description.
func (g *Generator) GenerateOrReset() Id {
	g.lock.Lock()
	defer g.lock.Unlock()
	return g.GenerateOrResetCore(uint64(time.Now().UnixMilli()), 10_000)
}

// Returns a new SCRU64 ID object, or sleeps and waits for one if not
// immediately available.
//
// See the [Generator] type documentation for the description.
func (g *Generator) GenerateOrSleep() Id {
	for {
		value, err := g.Generate()
		if err == nil {
			return value
		} else if err == ErrClockRollback {
			time.Sleep(64 * time.Millisecond)
		} else {
			panic("unreachable")
		}
	}
}

// Generates a new SCRU64 ID object from a Unix timestamp in milliseconds, or
// resets the generator upon significant timestamp rollback.
//
// See the [Generator] type documentation for the description.
//
// The `rollbackAllowance` parameter specifies the amount of `unixTsMs` rollback
// that is considered significant. A suggested value is `10_000` (milliseconds).
//
// Unlike [Generator.GenerateOrReset], this method is NOT thread-safe. The
// generator object should be protected from concurrent accesses using a mutex
// or other synchronization mechanism to avoid race conditions.
//
// This method panics if `unixTsMs` is not a positive integer within the valid
// range.
func (g *Generator) GenerateOrResetCore(
	unixTsMs uint64, rollbackAllowance uint64) Id {
	value, err := g.GenerateOrAbortCore(unixTsMs, rollbackAllowance)
	if err == nil {
		return value
	} else if err == ErrClockRollback {
		// reset state and resume
		timestamp := unixTsMs >> 8
		g.prev = mustFromParts(timestamp, g.renewNodeCtr(timestamp))
		return g.prev
	} else {
		panic("unreachable")
	}
}

// Generates a new SCRU64 ID object from a Unix timestamp in milliseconds, or
// returns an error upon significant timestamp rollback.
//
// See the [Generator] type documentation for the description.
//
// The `rollbackAllowance` parameter specifies the amount of `unixTsMs` rollback
// that is considered significant. A suggested value is `10_000` (milliseconds).
//
// Unlike [Generator.Generate], this method is NOT thread-safe. The generator
// object should be protected from concurrent accesses using a mutex or other
// synchronization mechanism to avoid race conditions.
//
// This method returns the [ErrClockRollback] error upon significant clock
// rollback.
//
// This method panics if `unixTsMs` is not a positive integer within the valid
// range.
func (g *Generator) GenerateOrAbortCore(
	unixTsMs uint64, rollbackAllowance uint64) (Id, error) {
	g.verify()
	timestamp := unixTsMs >> 8
	allowance := rollbackAllowance >> 8
	if timestamp == 0 || timestamp > maxTimestamp {
		panic("`timestamp` out of range")
	} else if allowance >= (1 << 40) {
		panic("`rollbackAllowance` out of reasonable range")
	}

	prevTimestamp := g.prev.Timestamp()
	if timestamp > prevTimestamp {
		g.prev = mustFromParts(timestamp, g.renewNodeCtr(timestamp))
	} else if timestamp+allowance >= prevTimestamp {
		// go on with previous timestamp if new one is not much smaller
		prevNodeCtr := g.prev.NodeCtr()
		counterMask := uint32(1)<<g.counterSize - 1
		if (prevNodeCtr & counterMask) < counterMask {
			g.prev = mustFromParts(prevTimestamp, prevNodeCtr+1)
		} else {
			// increment timestamp at counter overflow
			g.prev = mustFromParts(prevTimestamp+1, g.renewNodeCtr(prevTimestamp+1))
		}
	} else {
		// abort if clock went backwards to unbearable extent
		return Id(0), ErrClockRollback
	}
	return g.prev, nil
}
